// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'home_bloc.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

/// @nodoc
mixin _$HomeEvent {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() started,
    required TResult Function(String key) changeBool,
    required TResult Function(String key, String value) changeString,
    required TResult Function() getProducts,
    required TResult Function() getOrders,
    required TResult Function() scan,
    required TResult Function(int index) changeIndexNav,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? started,
    TResult? Function(String key)? changeBool,
    TResult? Function(String key, String value)? changeString,
    TResult? Function()? getProducts,
    TResult? Function()? getOrders,
    TResult? Function()? scan,
    TResult? Function(int index)? changeIndexNav,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? started,
    TResult Function(String key)? changeBool,
    TResult Function(String key, String value)? changeString,
    TResult Function()? getProducts,
    TResult Function()? getOrders,
    TResult Function()? scan,
    TResult Function(int index)? changeIndexNav,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Started value) started,
    required TResult Function(ChangeBool value) changeBool,
    required TResult Function(ChangeString value) changeString,
    required TResult Function(GetProducts value) getProducts,
    required TResult Function(GetOrders value) getOrders,
    required TResult Function(Scan value) scan,
    required TResult Function(ChangeIndexNav value) changeIndexNav,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Started value)? started,
    TResult? Function(ChangeBool value)? changeBool,
    TResult? Function(ChangeString value)? changeString,
    TResult? Function(GetProducts value)? getProducts,
    TResult? Function(GetOrders value)? getOrders,
    TResult? Function(Scan value)? scan,
    TResult? Function(ChangeIndexNav value)? changeIndexNav,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Started value)? started,
    TResult Function(ChangeBool value)? changeBool,
    TResult Function(ChangeString value)? changeString,
    TResult Function(GetProducts value)? getProducts,
    TResult Function(GetOrders value)? getOrders,
    TResult Function(Scan value)? scan,
    TResult Function(ChangeIndexNav value)? changeIndexNav,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $HomeEventCopyWith<$Res> {
  factory $HomeEventCopyWith(HomeEvent value, $Res Function(HomeEvent) then) =
      _$HomeEventCopyWithImpl<$Res, HomeEvent>;
}

/// @nodoc
class _$HomeEventCopyWithImpl<$Res, $Val extends HomeEvent>
    implements $HomeEventCopyWith<$Res> {
  _$HomeEventCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of HomeEvent
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc
abstract class _$$StartedImplCopyWith<$Res> {
  factory _$$StartedImplCopyWith(
          _$StartedImpl value, $Res Function(_$StartedImpl) then) =
      __$$StartedImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$StartedImplCopyWithImpl<$Res>
    extends _$HomeEventCopyWithImpl<$Res, _$StartedImpl>
    implements _$$StartedImplCopyWith<$Res> {
  __$$StartedImplCopyWithImpl(
      _$StartedImpl _value, $Res Function(_$StartedImpl) _then)
      : super(_value, _then);

  /// Create a copy of HomeEvent
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$StartedImpl implements Started {
  const _$StartedImpl();

  @override
  String toString() {
    return 'HomeEvent.started()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$StartedImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() started,
    required TResult Function(String key) changeBool,
    required TResult Function(String key, String value) changeString,
    required TResult Function() getProducts,
    required TResult Function() getOrders,
    required TResult Function() scan,
    required TResult Function(int index) changeIndexNav,
  }) {
    return started();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? started,
    TResult? Function(String key)? changeBool,
    TResult? Function(String key, String value)? changeString,
    TResult? Function()? getProducts,
    TResult? Function()? getOrders,
    TResult? Function()? scan,
    TResult? Function(int index)? changeIndexNav,
  }) {
    return started?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? started,
    TResult Function(String key)? changeBool,
    TResult Function(String key, String value)? changeString,
    TResult Function()? getProducts,
    TResult Function()? getOrders,
    TResult Function()? scan,
    TResult Function(int index)? changeIndexNav,
    required TResult orElse(),
  }) {
    if (started != null) {
      return started();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Started value) started,
    required TResult Function(ChangeBool value) changeBool,
    required TResult Function(ChangeString value) changeString,
    required TResult Function(GetProducts value) getProducts,
    required TResult Function(GetOrders value) getOrders,
    required TResult Function(Scan value) scan,
    required TResult Function(ChangeIndexNav value) changeIndexNav,
  }) {
    return started(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Started value)? started,
    TResult? Function(ChangeBool value)? changeBool,
    TResult? Function(ChangeString value)? changeString,
    TResult? Function(GetProducts value)? getProducts,
    TResult? Function(GetOrders value)? getOrders,
    TResult? Function(Scan value)? scan,
    TResult? Function(ChangeIndexNav value)? changeIndexNav,
  }) {
    return started?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Started value)? started,
    TResult Function(ChangeBool value)? changeBool,
    TResult Function(ChangeString value)? changeString,
    TResult Function(GetProducts value)? getProducts,
    TResult Function(GetOrders value)? getOrders,
    TResult Function(Scan value)? scan,
    TResult Function(ChangeIndexNav value)? changeIndexNav,
    required TResult orElse(),
  }) {
    if (started != null) {
      return started(this);
    }
    return orElse();
  }
}

abstract class Started implements HomeEvent {
  const factory Started() = _$StartedImpl;
}

/// @nodoc
abstract class _$$ChangeBoolImplCopyWith<$Res> {
  factory _$$ChangeBoolImplCopyWith(
          _$ChangeBoolImpl value, $Res Function(_$ChangeBoolImpl) then) =
      __$$ChangeBoolImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String key});
}

/// @nodoc
class __$$ChangeBoolImplCopyWithImpl<$Res>
    extends _$HomeEventCopyWithImpl<$Res, _$ChangeBoolImpl>
    implements _$$ChangeBoolImplCopyWith<$Res> {
  __$$ChangeBoolImplCopyWithImpl(
      _$ChangeBoolImpl _value, $Res Function(_$ChangeBoolImpl) _then)
      : super(_value, _then);

  /// Create a copy of HomeEvent
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? key = null,
  }) {
    return _then(_$ChangeBoolImpl(
      null == key
          ? _value.key
          : key // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$ChangeBoolImpl implements ChangeBool {
  const _$ChangeBoolImpl(this.key);

  @override
  final String key;

  @override
  String toString() {
    return 'HomeEvent.changeBool(key: $key)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ChangeBoolImpl &&
            (identical(other.key, key) || other.key == key));
  }

  @override
  int get hashCode => Object.hash(runtimeType, key);

  /// Create a copy of HomeEvent
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$ChangeBoolImplCopyWith<_$ChangeBoolImpl> get copyWith =>
      __$$ChangeBoolImplCopyWithImpl<_$ChangeBoolImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() started,
    required TResult Function(String key) changeBool,
    required TResult Function(String key, String value) changeString,
    required TResult Function() getProducts,
    required TResult Function() getOrders,
    required TResult Function() scan,
    required TResult Function(int index) changeIndexNav,
  }) {
    return changeBool(key);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? started,
    TResult? Function(String key)? changeBool,
    TResult? Function(String key, String value)? changeString,
    TResult? Function()? getProducts,
    TResult? Function()? getOrders,
    TResult? Function()? scan,
    TResult? Function(int index)? changeIndexNav,
  }) {
    return changeBool?.call(key);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? started,
    TResult Function(String key)? changeBool,
    TResult Function(String key, String value)? changeString,
    TResult Function()? getProducts,
    TResult Function()? getOrders,
    TResult Function()? scan,
    TResult Function(int index)? changeIndexNav,
    required TResult orElse(),
  }) {
    if (changeBool != null) {
      return changeBool(key);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Started value) started,
    required TResult Function(ChangeBool value) changeBool,
    required TResult Function(ChangeString value) changeString,
    required TResult Function(GetProducts value) getProducts,
    required TResult Function(GetOrders value) getOrders,
    required TResult Function(Scan value) scan,
    required TResult Function(ChangeIndexNav value) changeIndexNav,
  }) {
    return changeBool(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Started value)? started,
    TResult? Function(ChangeBool value)? changeBool,
    TResult? Function(ChangeString value)? changeString,
    TResult? Function(GetProducts value)? getProducts,
    TResult? Function(GetOrders value)? getOrders,
    TResult? Function(Scan value)? scan,
    TResult? Function(ChangeIndexNav value)? changeIndexNav,
  }) {
    return changeBool?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Started value)? started,
    TResult Function(ChangeBool value)? changeBool,
    TResult Function(ChangeString value)? changeString,
    TResult Function(GetProducts value)? getProducts,
    TResult Function(GetOrders value)? getOrders,
    TResult Function(Scan value)? scan,
    TResult Function(ChangeIndexNav value)? changeIndexNav,
    required TResult orElse(),
  }) {
    if (changeBool != null) {
      return changeBool(this);
    }
    return orElse();
  }
}

abstract class ChangeBool implements HomeEvent {
  const factory ChangeBool(final String key) = _$ChangeBoolImpl;

  String get key;

  /// Create a copy of HomeEvent
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$ChangeBoolImplCopyWith<_$ChangeBoolImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$ChangeStringImplCopyWith<$Res> {
  factory _$$ChangeStringImplCopyWith(
          _$ChangeStringImpl value, $Res Function(_$ChangeStringImpl) then) =
      __$$ChangeStringImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String key, String value});
}

/// @nodoc
class __$$ChangeStringImplCopyWithImpl<$Res>
    extends _$HomeEventCopyWithImpl<$Res, _$ChangeStringImpl>
    implements _$$ChangeStringImplCopyWith<$Res> {
  __$$ChangeStringImplCopyWithImpl(
      _$ChangeStringImpl _value, $Res Function(_$ChangeStringImpl) _then)
      : super(_value, _then);

  /// Create a copy of HomeEvent
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? key = null,
    Object? value = null,
  }) {
    return _then(_$ChangeStringImpl(
      null == key
          ? _value.key
          : key // ignore: cast_nullable_to_non_nullable
              as String,
      null == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$ChangeStringImpl implements ChangeString {
  const _$ChangeStringImpl(this.key, this.value);

  @override
  final String key;
  @override
  final String value;

  @override
  String toString() {
    return 'HomeEvent.changeString(key: $key, value: $value)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ChangeStringImpl &&
            (identical(other.key, key) || other.key == key) &&
            (identical(other.value, value) || other.value == value));
  }

  @override
  int get hashCode => Object.hash(runtimeType, key, value);

  /// Create a copy of HomeEvent
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$ChangeStringImplCopyWith<_$ChangeStringImpl> get copyWith =>
      __$$ChangeStringImplCopyWithImpl<_$ChangeStringImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() started,
    required TResult Function(String key) changeBool,
    required TResult Function(String key, String value) changeString,
    required TResult Function() getProducts,
    required TResult Function() getOrders,
    required TResult Function() scan,
    required TResult Function(int index) changeIndexNav,
  }) {
    return changeString(key, value);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? started,
    TResult? Function(String key)? changeBool,
    TResult? Function(String key, String value)? changeString,
    TResult? Function()? getProducts,
    TResult? Function()? getOrders,
    TResult? Function()? scan,
    TResult? Function(int index)? changeIndexNav,
  }) {
    return changeString?.call(key, value);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? started,
    TResult Function(String key)? changeBool,
    TResult Function(String key, String value)? changeString,
    TResult Function()? getProducts,
    TResult Function()? getOrders,
    TResult Function()? scan,
    TResult Function(int index)? changeIndexNav,
    required TResult orElse(),
  }) {
    if (changeString != null) {
      return changeString(key, value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Started value) started,
    required TResult Function(ChangeBool value) changeBool,
    required TResult Function(ChangeString value) changeString,
    required TResult Function(GetProducts value) getProducts,
    required TResult Function(GetOrders value) getOrders,
    required TResult Function(Scan value) scan,
    required TResult Function(ChangeIndexNav value) changeIndexNav,
  }) {
    return changeString(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Started value)? started,
    TResult? Function(ChangeBool value)? changeBool,
    TResult? Function(ChangeString value)? changeString,
    TResult? Function(GetProducts value)? getProducts,
    TResult? Function(GetOrders value)? getOrders,
    TResult? Function(Scan value)? scan,
    TResult? Function(ChangeIndexNav value)? changeIndexNav,
  }) {
    return changeString?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Started value)? started,
    TResult Function(ChangeBool value)? changeBool,
    TResult Function(ChangeString value)? changeString,
    TResult Function(GetProducts value)? getProducts,
    TResult Function(GetOrders value)? getOrders,
    TResult Function(Scan value)? scan,
    TResult Function(ChangeIndexNav value)? changeIndexNav,
    required TResult orElse(),
  }) {
    if (changeString != null) {
      return changeString(this);
    }
    return orElse();
  }
}

abstract class ChangeString implements HomeEvent {
  const factory ChangeString(final String key, final String value) =
      _$ChangeStringImpl;

  String get key;
  String get value;

  /// Create a copy of HomeEvent
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$ChangeStringImplCopyWith<_$ChangeStringImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$GetProductsImplCopyWith<$Res> {
  factory _$$GetProductsImplCopyWith(
          _$GetProductsImpl value, $Res Function(_$GetProductsImpl) then) =
      __$$GetProductsImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$GetProductsImplCopyWithImpl<$Res>
    extends _$HomeEventCopyWithImpl<$Res, _$GetProductsImpl>
    implements _$$GetProductsImplCopyWith<$Res> {
  __$$GetProductsImplCopyWithImpl(
      _$GetProductsImpl _value, $Res Function(_$GetProductsImpl) _then)
      : super(_value, _then);

  /// Create a copy of HomeEvent
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$GetProductsImpl implements GetProducts {
  const _$GetProductsImpl();

  @override
  String toString() {
    return 'HomeEvent.getProducts()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$GetProductsImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() started,
    required TResult Function(String key) changeBool,
    required TResult Function(String key, String value) changeString,
    required TResult Function() getProducts,
    required TResult Function() getOrders,
    required TResult Function() scan,
    required TResult Function(int index) changeIndexNav,
  }) {
    return getProducts();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? started,
    TResult? Function(String key)? changeBool,
    TResult? Function(String key, String value)? changeString,
    TResult? Function()? getProducts,
    TResult? Function()? getOrders,
    TResult? Function()? scan,
    TResult? Function(int index)? changeIndexNav,
  }) {
    return getProducts?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? started,
    TResult Function(String key)? changeBool,
    TResult Function(String key, String value)? changeString,
    TResult Function()? getProducts,
    TResult Function()? getOrders,
    TResult Function()? scan,
    TResult Function(int index)? changeIndexNav,
    required TResult orElse(),
  }) {
    if (getProducts != null) {
      return getProducts();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Started value) started,
    required TResult Function(ChangeBool value) changeBool,
    required TResult Function(ChangeString value) changeString,
    required TResult Function(GetProducts value) getProducts,
    required TResult Function(GetOrders value) getOrders,
    required TResult Function(Scan value) scan,
    required TResult Function(ChangeIndexNav value) changeIndexNav,
  }) {
    return getProducts(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Started value)? started,
    TResult? Function(ChangeBool value)? changeBool,
    TResult? Function(ChangeString value)? changeString,
    TResult? Function(GetProducts value)? getProducts,
    TResult? Function(GetOrders value)? getOrders,
    TResult? Function(Scan value)? scan,
    TResult? Function(ChangeIndexNav value)? changeIndexNav,
  }) {
    return getProducts?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Started value)? started,
    TResult Function(ChangeBool value)? changeBool,
    TResult Function(ChangeString value)? changeString,
    TResult Function(GetProducts value)? getProducts,
    TResult Function(GetOrders value)? getOrders,
    TResult Function(Scan value)? scan,
    TResult Function(ChangeIndexNav value)? changeIndexNav,
    required TResult orElse(),
  }) {
    if (getProducts != null) {
      return getProducts(this);
    }
    return orElse();
  }
}

abstract class GetProducts implements HomeEvent {
  const factory GetProducts() = _$GetProductsImpl;
}

/// @nodoc
abstract class _$$GetOrdersImplCopyWith<$Res> {
  factory _$$GetOrdersImplCopyWith(
          _$GetOrdersImpl value, $Res Function(_$GetOrdersImpl) then) =
      __$$GetOrdersImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$GetOrdersImplCopyWithImpl<$Res>
    extends _$HomeEventCopyWithImpl<$Res, _$GetOrdersImpl>
    implements _$$GetOrdersImplCopyWith<$Res> {
  __$$GetOrdersImplCopyWithImpl(
      _$GetOrdersImpl _value, $Res Function(_$GetOrdersImpl) _then)
      : super(_value, _then);

  /// Create a copy of HomeEvent
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$GetOrdersImpl implements GetOrders {
  const _$GetOrdersImpl();

  @override
  String toString() {
    return 'HomeEvent.getOrders()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$GetOrdersImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() started,
    required TResult Function(String key) changeBool,
    required TResult Function(String key, String value) changeString,
    required TResult Function() getProducts,
    required TResult Function() getOrders,
    required TResult Function() scan,
    required TResult Function(int index) changeIndexNav,
  }) {
    return getOrders();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? started,
    TResult? Function(String key)? changeBool,
    TResult? Function(String key, String value)? changeString,
    TResult? Function()? getProducts,
    TResult? Function()? getOrders,
    TResult? Function()? scan,
    TResult? Function(int index)? changeIndexNav,
  }) {
    return getOrders?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? started,
    TResult Function(String key)? changeBool,
    TResult Function(String key, String value)? changeString,
    TResult Function()? getProducts,
    TResult Function()? getOrders,
    TResult Function()? scan,
    TResult Function(int index)? changeIndexNav,
    required TResult orElse(),
  }) {
    if (getOrders != null) {
      return getOrders();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Started value) started,
    required TResult Function(ChangeBool value) changeBool,
    required TResult Function(ChangeString value) changeString,
    required TResult Function(GetProducts value) getProducts,
    required TResult Function(GetOrders value) getOrders,
    required TResult Function(Scan value) scan,
    required TResult Function(ChangeIndexNav value) changeIndexNav,
  }) {
    return getOrders(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Started value)? started,
    TResult? Function(ChangeBool value)? changeBool,
    TResult? Function(ChangeString value)? changeString,
    TResult? Function(GetProducts value)? getProducts,
    TResult? Function(GetOrders value)? getOrders,
    TResult? Function(Scan value)? scan,
    TResult? Function(ChangeIndexNav value)? changeIndexNav,
  }) {
    return getOrders?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Started value)? started,
    TResult Function(ChangeBool value)? changeBool,
    TResult Function(ChangeString value)? changeString,
    TResult Function(GetProducts value)? getProducts,
    TResult Function(GetOrders value)? getOrders,
    TResult Function(Scan value)? scan,
    TResult Function(ChangeIndexNav value)? changeIndexNav,
    required TResult orElse(),
  }) {
    if (getOrders != null) {
      return getOrders(this);
    }
    return orElse();
  }
}

abstract class GetOrders implements HomeEvent {
  const factory GetOrders() = _$GetOrdersImpl;
}

/// @nodoc
abstract class _$$ScanImplCopyWith<$Res> {
  factory _$$ScanImplCopyWith(
          _$ScanImpl value, $Res Function(_$ScanImpl) then) =
      __$$ScanImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$ScanImplCopyWithImpl<$Res>
    extends _$HomeEventCopyWithImpl<$Res, _$ScanImpl>
    implements _$$ScanImplCopyWith<$Res> {
  __$$ScanImplCopyWithImpl(_$ScanImpl _value, $Res Function(_$ScanImpl) _then)
      : super(_value, _then);

  /// Create a copy of HomeEvent
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$ScanImpl implements Scan {
  const _$ScanImpl();

  @override
  String toString() {
    return 'HomeEvent.scan()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$ScanImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() started,
    required TResult Function(String key) changeBool,
    required TResult Function(String key, String value) changeString,
    required TResult Function() getProducts,
    required TResult Function() getOrders,
    required TResult Function() scan,
    required TResult Function(int index) changeIndexNav,
  }) {
    return scan();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? started,
    TResult? Function(String key)? changeBool,
    TResult? Function(String key, String value)? changeString,
    TResult? Function()? getProducts,
    TResult? Function()? getOrders,
    TResult? Function()? scan,
    TResult? Function(int index)? changeIndexNav,
  }) {
    return scan?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? started,
    TResult Function(String key)? changeBool,
    TResult Function(String key, String value)? changeString,
    TResult Function()? getProducts,
    TResult Function()? getOrders,
    TResult Function()? scan,
    TResult Function(int index)? changeIndexNav,
    required TResult orElse(),
  }) {
    if (scan != null) {
      return scan();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Started value) started,
    required TResult Function(ChangeBool value) changeBool,
    required TResult Function(ChangeString value) changeString,
    required TResult Function(GetProducts value) getProducts,
    required TResult Function(GetOrders value) getOrders,
    required TResult Function(Scan value) scan,
    required TResult Function(ChangeIndexNav value) changeIndexNav,
  }) {
    return scan(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Started value)? started,
    TResult? Function(ChangeBool value)? changeBool,
    TResult? Function(ChangeString value)? changeString,
    TResult? Function(GetProducts value)? getProducts,
    TResult? Function(GetOrders value)? getOrders,
    TResult? Function(Scan value)? scan,
    TResult? Function(ChangeIndexNav value)? changeIndexNav,
  }) {
    return scan?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Started value)? started,
    TResult Function(ChangeBool value)? changeBool,
    TResult Function(ChangeString value)? changeString,
    TResult Function(GetProducts value)? getProducts,
    TResult Function(GetOrders value)? getOrders,
    TResult Function(Scan value)? scan,
    TResult Function(ChangeIndexNav value)? changeIndexNav,
    required TResult orElse(),
  }) {
    if (scan != null) {
      return scan(this);
    }
    return orElse();
  }
}

abstract class Scan implements HomeEvent {
  const factory Scan() = _$ScanImpl;
}

/// @nodoc
abstract class _$$ChangeIndexNavImplCopyWith<$Res> {
  factory _$$ChangeIndexNavImplCopyWith(_$ChangeIndexNavImpl value,
          $Res Function(_$ChangeIndexNavImpl) then) =
      __$$ChangeIndexNavImplCopyWithImpl<$Res>;
  @useResult
  $Res call({int index});
}

/// @nodoc
class __$$ChangeIndexNavImplCopyWithImpl<$Res>
    extends _$HomeEventCopyWithImpl<$Res, _$ChangeIndexNavImpl>
    implements _$$ChangeIndexNavImplCopyWith<$Res> {
  __$$ChangeIndexNavImplCopyWithImpl(
      _$ChangeIndexNavImpl _value, $Res Function(_$ChangeIndexNavImpl) _then)
      : super(_value, _then);

  /// Create a copy of HomeEvent
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? index = null,
  }) {
    return _then(_$ChangeIndexNavImpl(
      null == index
          ? _value.index
          : index // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc

class _$ChangeIndexNavImpl implements ChangeIndexNav {
  const _$ChangeIndexNavImpl(this.index);

  @override
  final int index;

  @override
  String toString() {
    return 'HomeEvent.changeIndexNav(index: $index)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ChangeIndexNavImpl &&
            (identical(other.index, index) || other.index == index));
  }

  @override
  int get hashCode => Object.hash(runtimeType, index);

  /// Create a copy of HomeEvent
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$ChangeIndexNavImplCopyWith<_$ChangeIndexNavImpl> get copyWith =>
      __$$ChangeIndexNavImplCopyWithImpl<_$ChangeIndexNavImpl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() started,
    required TResult Function(String key) changeBool,
    required TResult Function(String key, String value) changeString,
    required TResult Function() getProducts,
    required TResult Function() getOrders,
    required TResult Function() scan,
    required TResult Function(int index) changeIndexNav,
  }) {
    return changeIndexNav(index);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? started,
    TResult? Function(String key)? changeBool,
    TResult? Function(String key, String value)? changeString,
    TResult? Function()? getProducts,
    TResult? Function()? getOrders,
    TResult? Function()? scan,
    TResult? Function(int index)? changeIndexNav,
  }) {
    return changeIndexNav?.call(index);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? started,
    TResult Function(String key)? changeBool,
    TResult Function(String key, String value)? changeString,
    TResult Function()? getProducts,
    TResult Function()? getOrders,
    TResult Function()? scan,
    TResult Function(int index)? changeIndexNav,
    required TResult orElse(),
  }) {
    if (changeIndexNav != null) {
      return changeIndexNav(index);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Started value) started,
    required TResult Function(ChangeBool value) changeBool,
    required TResult Function(ChangeString value) changeString,
    required TResult Function(GetProducts value) getProducts,
    required TResult Function(GetOrders value) getOrders,
    required TResult Function(Scan value) scan,
    required TResult Function(ChangeIndexNav value) changeIndexNav,
  }) {
    return changeIndexNav(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Started value)? started,
    TResult? Function(ChangeBool value)? changeBool,
    TResult? Function(ChangeString value)? changeString,
    TResult? Function(GetProducts value)? getProducts,
    TResult? Function(GetOrders value)? getOrders,
    TResult? Function(Scan value)? scan,
    TResult? Function(ChangeIndexNav value)? changeIndexNav,
  }) {
    return changeIndexNav?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Started value)? started,
    TResult Function(ChangeBool value)? changeBool,
    TResult Function(ChangeString value)? changeString,
    TResult Function(GetProducts value)? getProducts,
    TResult Function(GetOrders value)? getOrders,
    TResult Function(Scan value)? scan,
    TResult Function(ChangeIndexNav value)? changeIndexNav,
    required TResult orElse(),
  }) {
    if (changeIndexNav != null) {
      return changeIndexNav(this);
    }
    return orElse();
  }
}

abstract class ChangeIndexNav implements HomeEvent {
  const factory ChangeIndexNav(final int index) = _$ChangeIndexNavImpl;

  int get index;

  /// Create a copy of HomeEvent
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$ChangeIndexNavImplCopyWith<_$ChangeIndexNavImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$HomeState {
  int get indexNav => throw _privateConstructorUsedError;
  bool get isLogin => throw _privateConstructorUsedError;
  bool get isSearchProduct => throw _privateConstructorUsedError;
  String get search_product_text => throw _privateConstructorUsedError;
  List<ProductModel> get list_product => throw _privateConstructorUsedError;
  List<OrderModel> get list_order => throw _privateConstructorUsedError;

  /// Create a copy of HomeState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $HomeStateCopyWith<HomeState> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $HomeStateCopyWith<$Res> {
  factory $HomeStateCopyWith(HomeState value, $Res Function(HomeState) then) =
      _$HomeStateCopyWithImpl<$Res, HomeState>;
  @useResult
  $Res call(
      {int indexNav,
      bool isLogin,
      bool isSearchProduct,
      String search_product_text,
      List<ProductModel> list_product,
      List<OrderModel> list_order});
}

/// @nodoc
class _$HomeStateCopyWithImpl<$Res, $Val extends HomeState>
    implements $HomeStateCopyWith<$Res> {
  _$HomeStateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of HomeState
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? indexNav = null,
    Object? isLogin = null,
    Object? isSearchProduct = null,
    Object? search_product_text = null,
    Object? list_product = null,
    Object? list_order = null,
  }) {
    return _then(_value.copyWith(
      indexNav: null == indexNav
          ? _value.indexNav
          : indexNav // ignore: cast_nullable_to_non_nullable
              as int,
      isLogin: null == isLogin
          ? _value.isLogin
          : isLogin // ignore: cast_nullable_to_non_nullable
              as bool,
      isSearchProduct: null == isSearchProduct
          ? _value.isSearchProduct
          : isSearchProduct // ignore: cast_nullable_to_non_nullable
              as bool,
      search_product_text: null == search_product_text
          ? _value.search_product_text
          : search_product_text // ignore: cast_nullable_to_non_nullable
              as String,
      list_product: null == list_product
          ? _value.list_product
          : list_product // ignore: cast_nullable_to_non_nullable
              as List<ProductModel>,
      list_order: null == list_order
          ? _value.list_order
          : list_order // ignore: cast_nullable_to_non_nullable
              as List<OrderModel>,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$HomeStateImplCopyWith<$Res>
    implements $HomeStateCopyWith<$Res> {
  factory _$$HomeStateImplCopyWith(
          _$HomeStateImpl value, $Res Function(_$HomeStateImpl) then) =
      __$$HomeStateImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {int indexNav,
      bool isLogin,
      bool isSearchProduct,
      String search_product_text,
      List<ProductModel> list_product,
      List<OrderModel> list_order});
}

/// @nodoc
class __$$HomeStateImplCopyWithImpl<$Res>
    extends _$HomeStateCopyWithImpl<$Res, _$HomeStateImpl>
    implements _$$HomeStateImplCopyWith<$Res> {
  __$$HomeStateImplCopyWithImpl(
      _$HomeStateImpl _value, $Res Function(_$HomeStateImpl) _then)
      : super(_value, _then);

  /// Create a copy of HomeState
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? indexNav = null,
    Object? isLogin = null,
    Object? isSearchProduct = null,
    Object? search_product_text = null,
    Object? list_product = null,
    Object? list_order = null,
  }) {
    return _then(_$HomeStateImpl(
      indexNav: null == indexNav
          ? _value.indexNav
          : indexNav // ignore: cast_nullable_to_non_nullable
              as int,
      isLogin: null == isLogin
          ? _value.isLogin
          : isLogin // ignore: cast_nullable_to_non_nullable
              as bool,
      isSearchProduct: null == isSearchProduct
          ? _value.isSearchProduct
          : isSearchProduct // ignore: cast_nullable_to_non_nullable
              as bool,
      search_product_text: null == search_product_text
          ? _value.search_product_text
          : search_product_text // ignore: cast_nullable_to_non_nullable
              as String,
      list_product: null == list_product
          ? _value._list_product
          : list_product // ignore: cast_nullable_to_non_nullable
              as List<ProductModel>,
      list_order: null == list_order
          ? _value._list_order
          : list_order // ignore: cast_nullable_to_non_nullable
              as List<OrderModel>,
    ));
  }
}

/// @nodoc

class _$HomeStateImpl implements _HomeState {
  const _$HomeStateImpl(
      {this.indexNav = 0,
      this.isLogin = false,
      this.isSearchProduct = false,
      this.search_product_text = '',
      final List<ProductModel> list_product = const [],
      final List<OrderModel> list_order = const []})
      : _list_product = list_product,
        _list_order = list_order;

  @override
  @JsonKey()
  final int indexNav;
  @override
  @JsonKey()
  final bool isLogin;
  @override
  @JsonKey()
  final bool isSearchProduct;
  @override
  @JsonKey()
  final String search_product_text;
  final List<ProductModel> _list_product;
  @override
  @JsonKey()
  List<ProductModel> get list_product {
    if (_list_product is EqualUnmodifiableListView) return _list_product;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_list_product);
  }

  final List<OrderModel> _list_order;
  @override
  @JsonKey()
  List<OrderModel> get list_order {
    if (_list_order is EqualUnmodifiableListView) return _list_order;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_list_order);
  }

  @override
  String toString() {
    return 'HomeState(indexNav: $indexNav, isLogin: $isLogin, isSearchProduct: $isSearchProduct, search_product_text: $search_product_text, list_product: $list_product, list_order: $list_order)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$HomeStateImpl &&
            (identical(other.indexNav, indexNav) ||
                other.indexNav == indexNav) &&
            (identical(other.isLogin, isLogin) || other.isLogin == isLogin) &&
            (identical(other.isSearchProduct, isSearchProduct) ||
                other.isSearchProduct == isSearchProduct) &&
            (identical(other.search_product_text, search_product_text) ||
                other.search_product_text == search_product_text) &&
            const DeepCollectionEquality()
                .equals(other._list_product, _list_product) &&
            const DeepCollectionEquality()
                .equals(other._list_order, _list_order));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      indexNav,
      isLogin,
      isSearchProduct,
      search_product_text,
      const DeepCollectionEquality().hash(_list_product),
      const DeepCollectionEquality().hash(_list_order));

  /// Create a copy of HomeState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$HomeStateImplCopyWith<_$HomeStateImpl> get copyWith =>
      __$$HomeStateImplCopyWithImpl<_$HomeStateImpl>(this, _$identity);
}

abstract class _HomeState implements HomeState {
  const factory _HomeState(
      {final int indexNav,
      final bool isLogin,
      final bool isSearchProduct,
      final String search_product_text,
      final List<ProductModel> list_product,
      final List<OrderModel> list_order}) = _$HomeStateImpl;

  @override
  int get indexNav;
  @override
  bool get isLogin;
  @override
  bool get isSearchProduct;
  @override
  String get search_product_text;
  @override
  List<ProductModel> get list_product;
  @override
  List<OrderModel> get list_order;

  /// Create a copy of HomeState
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$HomeStateImplCopyWith<_$HomeStateImpl> get copyWith =>
      throw _privateConstructorUsedError;
}
